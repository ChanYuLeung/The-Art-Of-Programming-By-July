#回文判断


## 题目描述

给定一个字符串，判断它是否是回文。

我们这里的回文（英文：palindrome）是指一个顺着读和反过来读都一样的字符串，比如“madam”、“信言不美，美言不信”和“哥曾信佛但佛信曾哥”等。这样的短句在智力性、趣味性和艺术性上都颇有特色。

## 分析与解法

回文判断是一类典型的问题，尤其是与字符串结合后呈现出多姿多彩，在实际中使用也比较广泛，而且也是面试题中的常客，所以本节就结合几个典型的例子来体味下回文之趣。

### 解法一

同时从字符串头尾开始向中间扫描字串，如果所有字符都一样，那么这个字串就是一个回文。采用这种方法的话，我们只需要维护头部和尾部两个扫描指针即可。
代码如下：  

```cpp
/**  
 *检查字符串s是不是回文, 字符串s的长度为n 
 *Copyright(C) fairywell 2011 
 */  
bool IsPalindrome(const char *s, int n)  
{  
    if (s == NULL || n < 1) return false; // 非法输入  
    char *front, *back;  
    front = s; back = s + n - 1; // 初始化头指针和尾指针  
    while (front < back) {  
        if (*front != *back) 
          return false; // 不是回文，立即返回  
        ++front; 
        --back;  
    }  
    return true; // 是回文  
}  
```

这是一个直白且效率不错的实现，时间复杂度：O(n)，空间复杂度：2。


### 解法二

解法一从字符串的头尾向中间扫描，那么是否还有其它办法呢？我们可以先从中间开始，向两边扩展比较字符是否相等。参考代码如下：

```cpp
/**  
 *检查字符串s是不是回文, 字符串s的长度为n 
 *Copyright(C) fairywell 2011 
 */  
bool IsPalindrome2(const char *s, int n)  
{  
    if (s == NULL || n < 1) return false; // 非法输入  
    char *first, *second;  
    int m = ((n >> 1) - 1) >= 0 ? (n >> 1) - 1 : 0; // m是字符串的中间位置        
    first = s + m; second = s + n - 1 - m;  
    while (first >= s)  
        if (s[first--] != s[second++]) return false; // 不是回文，立即返回  
    return true; // 是回文  
}  
```

解法二的时空复杂度和解法一相同。

那么除了使用数组，是否可以使用单链表和栈判断字符串是否为回文呢？

1.使用单链表：先将字符串放入单链表中。然后，套用解法一的思路。但问题的关键是如何朝两个方向遍历。因为单链表是单向的，不能直接上一个节点方向遍历。如需向两个方向遍历，可以采取经典的快慢指针的方法：即先定位到链表的中间位置，再将链表的后半逆置，最后用两个指针同时从链表头部和中间开始遍历并比较。

2.使用栈：只需要将字符串全部压入栈，然后依次将各字符出栈，这样得到的就是原字符串的逆置串。将逆置串和原字符串各个字符比较即可。
